// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Util$FpCourseReason = require("./Util.bs.js");

function headOr(x, xs) {
  if (xs) {
    return xs.hd;
  } else {
    return x;
  }
}

function headOr2(z, xs) {
  return List.fold_right(Util$FpCourseReason.$$const, xs, z);
}

function product(xs) {
  return List.fold_left((function (prim, prim$1) {
                return Math.imul(prim, prim$1);
              }), 1, xs);
}

function sum(xs) {
  return List.fold_left((function (prim, prim$1) {
                return prim + prim$1 | 0;
              }), 0, xs);
}

function length(xs) {
  return List.fold_left((function (acc, param) {
                return acc + 1 | 0;
              }), 0, xs);
}

function map(f, xs) {
  return List.fold_right((function (x, acc) {
                return {
                        hd: Curry._1(f, x),
                        tl: acc
                      };
              }), xs, /* [] */0);
}

function filter(f, xs) {
  return List.fold_right((function (x, acc) {
                if (Curry._1(f, x)) {
                  return {
                          hd: x,
                          tl: acc
                        };
                } else {
                  return acc;
                }
              }), xs, /* [] */0);
}

function $plus$plus$plus(xs, ys) {
  return List.fold_right((function (x, acc) {
                return {
                        hd: x,
                        tl: acc
                      };
              }), xs, ys);
}

function flatten(xs) {
  return List.fold_right($plus$plus$plus, xs, /* [] */0);
}

function flatMap(f, xs) {
  return List.fold_right($plus$plus$plus, map(f, xs), /* [] */0);
}

function flatMap2(f, xs) {
  return List.fold_right($plus$plus$plus, map(f, xs), /* [] */0);
}

function flatMapWithCompose(f) {
  return function (param) {
    return Util$FpCourseReason.$less$dot$great(flatten, (function (param) {
                  return map(f, param);
                }), param);
  };
}

function flattenAgain(xs) {
  return List.fold_right($plus$plus$plus, map(Util$FpCourseReason.id, xs), /* [] */0);
}

function seqOptional(xs) {
  return List.fold_right((function (xOpt, accOpt) {
                if (xOpt !== undefined && accOpt !== undefined) {
                  return {
                          hd: Caml_option.valFromOption(xOpt),
                          tl: accOpt
                        };
                }
                
              }), xs, /* [] */0);
}

function seqOptional2(xs) {
  var f = function (xOpt, accOpt) {
    return Belt_Option.flatMap(xOpt, (function (x) {
                  return Belt_Option.flatMap(accOpt, (function (acc) {
                                return {
                                        hd: x,
                                        tl: acc
                                      };
                              }));
                }));
  };
  return List.fold_right(f, xs, /* [] */0);
}

function find(f, _xs) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return ;
    }
    var x = xs.hd;
    if (Curry._1(f, x)) {
      return Caml_option.some(x);
    }
    _xs = xs.tl;
    continue ;
  };
}

function find2(f, xs) {
  var match = filter(f, xs);
  if (match) {
    return Caml_option.some(match.hd);
  }
  
}

function lengthGT4(xs) {
  if (!xs) {
    return false;
  }
  var match = xs.tl;
  if (!match) {
    return false;
  }
  var match$1 = match.tl;
  if (!match$1) {
    return false;
  }
  var match$2 = match$1.tl;
  if (!match$2) {
    return false;
  }
  var match$3 = match$2.tl;
  if (match$3 && !match$3.tl) {
    return true;
  } else {
    return false;
  }
}

function reverse(xs) {
  return List.fold_left((function (acc, x) {
                return {
                        hd: x,
                        tl: acc
                      };
              }), /* [] */0, xs);
}

function appendHead(x, xs) {
  return {
          hd: x,
          tl: xs
        };
}

function reverse2(xs) {
  return List.fold_left((function (param, param$1) {
                return Util$FpCourseReason.flip(appendHead, param, param$1);
              }), /* [] */0, xs);
}

exports.headOr = headOr;
exports.headOr2 = headOr2;
exports.product = product;
exports.sum = sum;
exports.length = length;
exports.map = map;
exports.filter = filter;
exports.$plus$plus$plus = $plus$plus$plus;
exports.flatten = flatten;
exports.flatMap = flatMap;
exports.flatMap2 = flatMap2;
exports.flatMapWithCompose = flatMapWithCompose;
exports.flattenAgain = flattenAgain;
exports.seqOptional = seqOptional;
exports.seqOptional2 = seqOptional2;
exports.find = find;
exports.find2 = find2;
exports.lengthGT4 = lengthGT4;
exports.reverse = reverse;
exports.appendHead = appendHead;
exports.reverse2 = reverse2;
/* No side effect */
