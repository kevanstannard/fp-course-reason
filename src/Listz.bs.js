// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Util$FpCourseReason = require("./Util.bs.js");

function headOr(x, xs) {
  if (xs) {
    return xs[0];
  } else {
    return x;
  }
}

function headOr2(z, xs) {
  return List.fold_right(Util$FpCourseReason.$$const, xs, z);
}

function product(xs) {
  return List.fold_left(Caml_int32.imul, 1, xs);
}

function sum(xs) {
  return List.fold_left((function (prim, prim$1) {
                return prim + prim$1 | 0;
              }), 0, xs);
}

function length(xs) {
  return List.fold_left((function (acc, param) {
                return acc + 1 | 0;
              }), 0, xs);
}

function map(f, xs) {
  return List.fold_right((function (x, acc) {
                return /* :: */[
                        Curry._1(f, x),
                        acc
                      ];
              }), xs, /* [] */0);
}

function filter(f, xs) {
  return List.fold_right((function (x, acc) {
                var match = Curry._1(f, x);
                if (match) {
                  return /* :: */[
                          x,
                          acc
                        ];
                } else {
                  return acc;
                }
              }), xs, /* [] */0);
}

function $plus$plus$plus(xs, ys) {
  return List.fold_right((function (x, acc) {
                return /* :: */[
                        x,
                        acc
                      ];
              }), xs, ys);
}

function flatten(xs) {
  return List.fold_right($plus$plus$plus, xs, /* [] */0);
}

function flatMap(f, xs) {
  var xs$1 = map(f, xs);
  return List.fold_right($plus$plus$plus, xs$1, /* [] */0);
}

function flatMap2(f, xs) {
  var xs$1 = map(f, xs);
  return List.fold_right($plus$plus$plus, xs$1, /* [] */0);
}

function flatMapWithCompose(f) {
  return (function (param) {
      return Util$FpCourseReason.$less$dot$great(flatten, (function (param) {
                    return map(f, param);
                  }), param);
    });
}

function flattenAgain(xs) {
  var xs$1 = map(Util$FpCourseReason.id, xs);
  return List.fold_right($plus$plus$plus, xs$1, /* [] */0);
}

function seqOptional(xs) {
  return List.fold_right((function (xOpt, accOpt) {
                if (xOpt !== undefined && accOpt !== undefined) {
                  return /* :: */[
                          Caml_option.valFromOption(xOpt),
                          accOpt
                        ];
                }
                
              }), xs, /* [] */0);
}

function seqOptional2(xs) {
  var f = function (xOpt, accOpt) {
    return Belt_Option.flatMap(xOpt, (function (x) {
                  return Belt_Option.flatMap(accOpt, (function (acc) {
                                return /* :: */[
                                        x,
                                        acc
                                      ];
                              }));
                }));
  };
  return List.fold_right(f, xs, /* [] */0);
}

function find(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      var x = xs[0];
      var match = Curry._1(f, x);
      if (match) {
        return Caml_option.some(x);
      } else {
        _xs = xs[1];
        continue ;
      }
    } else {
      return ;
    }
  };
}

function find2(f, xs) {
  var match = filter(f, xs);
  if (match) {
    return Caml_option.some(match[0]);
  }
  
}

function lengthGT4(xs) {
  if (xs) {
    var match = xs[1];
    if (match) {
      var match$1 = match[1];
      if (match$1) {
        var match$2 = match$1[1];
        if (match$2) {
          var match$3 = match$2[1];
          if (match$3 && !match$3[1]) {
            return true;
          } else {
            return false;
          }
        } else {
          return false;
        }
      } else {
        return false;
      }
    } else {
      return false;
    }
  } else {
    return false;
  }
}

function reverse(xs) {
  return List.fold_left((function (acc, x) {
                return /* :: */[
                        x,
                        acc
                      ];
              }), /* [] */0, xs);
}

function appendHead(x, xs) {
  return /* :: */[
          x,
          xs
        ];
}

function reverse2(xs) {
  return List.fold_left((function (param, param$1) {
                return Util$FpCourseReason.flip(appendHead, param, param$1);
              }), /* [] */0, xs);
}

exports.headOr = headOr;
exports.headOr2 = headOr2;
exports.product = product;
exports.sum = sum;
exports.length = length;
exports.map = map;
exports.filter = filter;
exports.$plus$plus$plus = $plus$plus$plus;
exports.flatten = flatten;
exports.flatMap = flatMap;
exports.flatMap2 = flatMap2;
exports.flatMapWithCompose = flatMapWithCompose;
exports.flattenAgain = flattenAgain;
exports.seqOptional = seqOptional;
exports.seqOptional2 = seqOptional2;
exports.find = find;
exports.find2 = find2;
exports.lengthGT4 = lengthGT4;
exports.reverse = reverse;
exports.appendHead = appendHead;
exports.reverse2 = reverse2;
/* Util-FpCourseReason Not a pure module */
